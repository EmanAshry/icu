
GccApplication1.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         000004d0  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000000  00800060  000004d0  00000564  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000009  00800060  00800060  00000564  2**0
                  ALLOC
  3 .stab         000006cc  00000000  00000000  00000564  2**2
                  CONTENTS, READONLY, DEBUGGING
  4 .stabstr      00000097  00000000  00000000  00000c30  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .comment      0000002f  00000000  00000000  00000cc7  2**0
                  CONTENTS, READONLY
  6 .debug_aranges 000001a8  00000000  00000000  00000cf6  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_info   00001866  00000000  00000000  00000e9e  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_abbrev 000005ab  00000000  00000000  00002704  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_line   00000515  00000000  00000000  00002caf  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_frame  000003d4  00000000  00000000  000031c4  2**2
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_str    0000099c  00000000  00000000  00003598  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_loc    000011d6  00000000  00000000  00003f34  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_ranges 00000158  00000000  00000000  0000510a  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
   0:	0c 94 2a 00 	jmp	0x54	; 0x54 <__ctors_end>
   4:	0c 94 3e 00 	jmp	0x7c	; 0x7c <__vector_1>
   8:	0c 94 3c 00 	jmp	0x78	; 0x78 <__bad_interrupt>
   c:	0c 94 3c 00 	jmp	0x78	; 0x78 <__bad_interrupt>
  10:	0c 94 3c 00 	jmp	0x78	; 0x78 <__bad_interrupt>
  14:	0c 94 3c 00 	jmp	0x78	; 0x78 <__bad_interrupt>
  18:	0c 94 3c 00 	jmp	0x78	; 0x78 <__bad_interrupt>
  1c:	0c 94 3c 00 	jmp	0x78	; 0x78 <__bad_interrupt>
  20:	0c 94 3c 00 	jmp	0x78	; 0x78 <__bad_interrupt>
  24:	0c 94 3c 00 	jmp	0x78	; 0x78 <__bad_interrupt>
  28:	0c 94 3c 00 	jmp	0x78	; 0x78 <__bad_interrupt>
  2c:	0c 94 3c 00 	jmp	0x78	; 0x78 <__bad_interrupt>
  30:	0c 94 3c 00 	jmp	0x78	; 0x78 <__bad_interrupt>
  34:	0c 94 3c 00 	jmp	0x78	; 0x78 <__bad_interrupt>
  38:	0c 94 3c 00 	jmp	0x78	; 0x78 <__bad_interrupt>
  3c:	0c 94 3c 00 	jmp	0x78	; 0x78 <__bad_interrupt>
  40:	0c 94 3c 00 	jmp	0x78	; 0x78 <__bad_interrupt>
  44:	0c 94 3c 00 	jmp	0x78	; 0x78 <__bad_interrupt>
  48:	0c 94 3c 00 	jmp	0x78	; 0x78 <__bad_interrupt>
  4c:	0c 94 3c 00 	jmp	0x78	; 0x78 <__bad_interrupt>
  50:	0c 94 3c 00 	jmp	0x78	; 0x78 <__bad_interrupt>

00000054 <__ctors_end>:
  54:	11 24       	eor	r1, r1
  56:	1f be       	out	0x3f, r1	; 63
  58:	cf e5       	ldi	r28, 0x5F	; 95
  5a:	d8 e0       	ldi	r29, 0x08	; 8
  5c:	de bf       	out	0x3e, r29	; 62
  5e:	cd bf       	out	0x3d, r28	; 61

00000060 <__do_clear_bss>:
  60:	20 e0       	ldi	r18, 0x00	; 0
  62:	a0 e6       	ldi	r26, 0x60	; 96
  64:	b0 e0       	ldi	r27, 0x00	; 0
  66:	01 c0       	rjmp	.+2      	; 0x6a <.do_clear_bss_start>

00000068 <.do_clear_bss_loop>:
  68:	1d 92       	st	X+, r1

0000006a <.do_clear_bss_start>:
  6a:	a9 36       	cpi	r26, 0x69	; 105
  6c:	b2 07       	cpc	r27, r18
  6e:	e1 f7       	brne	.-8      	; 0x68 <.do_clear_bss_loop>
  70:	0e 94 73 00 	call	0xe6	; 0xe6 <main>
  74:	0c 94 66 02 	jmp	0x4cc	; 0x4cc <_exit>

00000078 <__bad_interrupt>:
  78:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

0000007c <__vector_1>:
#include <stdio.h>
#include <stdlib.h>
#include "SwICU.h"

ISR(INT0_vect)
{
  7c:	1f 92       	push	r1
  7e:	0f 92       	push	r0
  80:	0f b6       	in	r0, 0x3f	; 63
  82:	0f 92       	push	r0
  84:	11 24       	eor	r1, r1
  86:	2f 93       	push	r18
  88:	3f 93       	push	r19
  8a:	4f 93       	push	r20
  8c:	5f 93       	push	r21
  8e:	6f 93       	push	r22
  90:	7f 93       	push	r23
  92:	8f 93       	push	r24
  94:	9f 93       	push	r25
  96:	af 93       	push	r26
  98:	bf 93       	push	r27
  9a:	ef 93       	push	r30
  9c:	ff 93       	push	r31
	if(Current_Edge==SwICU_EdgeRisiging)
  9e:	80 91 68 00 	lds	r24, 0x0068
  a2:	83 30       	cpi	r24, 0x03	; 3
  a4:	49 f4       	brne	.+18     	; 0xb8 <__vector_1+0x3c>
	{
		timer0Start();
  a6:	0e 94 0e 02 	call	0x41c	; 0x41c <timer0Start>
		SwICU_SetCfgEdge(SwICU_EdgeFalling);
  aa:	82 e0       	ldi	r24, 0x02	; 2
  ac:	0e 94 d1 01 	call	0x3a2	; 0x3a2 <SwICU_SetCfgEdge>
		Current_Edge = SwICU_EdgeFalling;
  b0:	82 e0       	ldi	r24, 0x02	; 2
  b2:	80 93 68 00 	sts	0x0068, r24
  b6:	06 c0       	rjmp	.+12     	; 0xc4 <__vector_1+0x48>
	}
	else
	{
		timer0Stop();
  b8:	0e 94 14 02 	call	0x428	; 0x428 <timer0Stop>
		SwICU_Read(&pu8_capt);
  bc:	87 e6       	ldi	r24, 0x67	; 103
  be:	90 e0       	ldi	r25, 0x00	; 0
  c0:	0e 94 dd 01 	call	0x3ba	; 0x3ba <SwICU_Read>
	}
}
  c4:	ff 91       	pop	r31
  c6:	ef 91       	pop	r30
  c8:	bf 91       	pop	r27
  ca:	af 91       	pop	r26
  cc:	9f 91       	pop	r25
  ce:	8f 91       	pop	r24
  d0:	7f 91       	pop	r23
  d2:	6f 91       	pop	r22
  d4:	5f 91       	pop	r21
  d6:	4f 91       	pop	r20
  d8:	3f 91       	pop	r19
  da:	2f 91       	pop	r18
  dc:	0f 90       	pop	r0
  de:	0f be       	out	0x3f, r0	; 63
  e0:	0f 90       	pop	r0
  e2:	1f 90       	pop	r1
  e4:	18 95       	reti

000000e6 <main>:

int main()
{
	Led_Init(LED_0);
  e6:	80 e0       	ldi	r24, 0x00	; 0
  e8:	0e 94 5d 01 	call	0x2ba	; 0x2ba <Led_Init>
	Led_Init(LED_1);
  ec:	81 e0       	ldi	r24, 0x01	; 1
  ee:	0e 94 5d 01 	call	0x2ba	; 0x2ba <Led_Init>
	Led_Init(LED_2);
  f2:	82 e0       	ldi	r24, 0x02	; 2
  f4:	0e 94 5d 01 	call	0x2ba	; 0x2ba <Led_Init>
	Led_Init(LED_3);
  f8:	83 e0       	ldi	r24, 0x03	; 3
  fa:	0e 94 5d 01 	call	0x2ba	; 0x2ba <Led_Init>

	Led_Off(LED_0);
  fe:	80 e0       	ldi	r24, 0x00	; 0
 100:	0e 94 7d 01 	call	0x2fa	; 0x2fa <Led_Off>
	Led_Off(LED_1);
 104:	81 e0       	ldi	r24, 0x01	; 1
 106:	0e 94 7d 01 	call	0x2fa	; 0x2fa <Led_Off>
	Led_Off(LED_2);
 10a:	82 e0       	ldi	r24, 0x02	; 2
 10c:	0e 94 7d 01 	call	0x2fa	; 0x2fa <Led_Off>
	Led_Off(LED_3);
 110:	83 e0       	ldi	r24, 0x03	; 3
 112:	0e 94 7d 01 	call	0x2fa	; 0x2fa <Led_Off>

	gpioPortDirection(GPIOB,OUTPUT);
 116:	6f ef       	ldi	r22, 0xFF	; 255
 118:	81 e0       	ldi	r24, 0x01	; 1
 11a:	0e 94 bd 00 	call	0x17a	; 0x17a <gpioPortDirection>
	gpioPinDirection(GPIOB,BIT2,INPUT);
 11e:	40 e0       	ldi	r20, 0x00	; 0
 120:	64 e0       	ldi	r22, 0x04	; 4
 122:	81 e0       	ldi	r24, 0x01	; 1
 124:	0e 94 dd 00 	call	0x1ba	; 0x1ba <gpioPinDirection>

	uint8_t Distance=0;

	SwICU_Init(SwICU_EdgeRisiging);
 128:	83 e0       	ldi	r24, 0x03	; 3
 12a:	0e 94 9d 01 	call	0x33a	; 0x33a <SwICU_Init>
	SwICU_Start();
 12e:	0e 94 e6 01 	call	0x3cc	; 0x3cc <SwICU_Start>



		if(ISCLEAR(TIFR,0x01))
		{
			Distance = (pu8_capt*16)/58;          //DIstance in cm
 132:	ca e3       	ldi	r28, 0x3A	; 58
 134:	d0 e0       	ldi	r29, 0x00	; 0
	SwICU_Init(SwICU_EdgeRisiging);
	SwICU_Start();

	while(1)
	{
		gpioPinWrite(GPIOB,BIT1,1);
 136:	41 e0       	ldi	r20, 0x01	; 1
 138:	62 e0       	ldi	r22, 0x02	; 2
 13a:	81 e0       	ldi	r24, 0x01	; 1
 13c:	0e 94 0e 01 	call	0x21c	; 0x21c <gpioPinWrite>
		timer0DelayMs(1);
 140:	81 e0       	ldi	r24, 0x01	; 1
 142:	90 e0       	ldi	r25, 0x00	; 0
 144:	0e 94 18 02 	call	0x430	; 0x430 <timer0DelayMs>
		gpioPinWrite(GPIOB,BIT1,0);
 148:	40 e0       	ldi	r20, 0x00	; 0
 14a:	62 e0       	ldi	r22, 0x02	; 2
 14c:	81 e0       	ldi	r24, 0x01	; 1
 14e:	0e 94 0e 01 	call	0x21c	; 0x21c <gpioPinWrite>



		if(ISCLEAR(TIFR,0x01))
 152:	08 b6       	in	r0, 0x38	; 56
 154:	00 fc       	sbrc	r0, 0
 156:	0a c0       	rjmp	.+20     	; 0x16c <main+0x86>
		{
			Distance = (pu8_capt*16)/58;          //DIstance in cm
 158:	80 91 67 00 	lds	r24, 0x0067
 15c:	20 e1       	ldi	r18, 0x10	; 16
 15e:	82 9f       	mul	r24, r18
 160:	c0 01       	movw	r24, r0
 162:	11 24       	eor	r1, r1
 164:	be 01       	movw	r22, r28
 166:	0e 94 3e 02 	call	0x47c	; 0x47c <__divmodhi4>
 16a:	01 c0       	rjmp	.+2      	; 0x16e <main+0x88>
		}
		else
		{
			Distance = 0;
 16c:	60 e0       	ldi	r22, 0x00	; 0
		}

		gpioPortWrite(GPIOB,(Distance<<4));
 16e:	62 95       	swap	r22
 170:	60 7f       	andi	r22, 0xF0	; 240
 172:	81 e0       	ldi	r24, 0x01	; 1
 174:	0e 94 cd 00 	call	0x19a	; 0x19a <gpioPortWrite>
	}
 178:	de cf       	rjmp	.-68     	; 0x136 <main+0x50>

0000017a <gpioPortDirection>:
#include "gpio.h"
#include "registers.h"

void gpioPortDirection(uint8_t u8_port, uint8_t u8_direction)
{
	switch (u8_port)
 17a:	81 30       	cpi	r24, 0x01	; 1
 17c:	41 f0       	breq	.+16     	; 0x18e <gpioPortDirection+0x14>
 17e:	28 f0       	brcs	.+10     	; 0x18a <gpioPortDirection+0x10>
 180:	82 30       	cpi	r24, 0x02	; 2
 182:	39 f0       	breq	.+14     	; 0x192 <gpioPortDirection+0x18>
 184:	83 30       	cpi	r24, 0x03	; 3
 186:	41 f4       	brne	.+16     	; 0x198 <gpioPortDirection+0x1e>
 188:	06 c0       	rjmp	.+12     	; 0x196 <gpioPortDirection+0x1c>
	{
	case GPIOA:
		PORTA_DIR = u8_direction;
 18a:	6a bb       	out	0x1a, r22	; 26
		break;
 18c:	08 95       	ret
	case GPIOB:
		PORTB_DIR = u8_direction;
 18e:	67 bb       	out	0x17, r22	; 23
		break;
 190:	08 95       	ret
	case GPIOC:
		PORTC_DIR = u8_direction;
 192:	64 bb       	out	0x14, r22	; 20
		break;
 194:	08 95       	ret
	case GPIOD:
		PORTD_DIR = u8_direction;
 196:	61 bb       	out	0x11, r22	; 17
 198:	08 95       	ret

0000019a <gpioPortWrite>:
	}
}

void gpioPortWrite(uint8_t u8_port, uint8_t u8_value)
{
	switch (u8_port)
 19a:	81 30       	cpi	r24, 0x01	; 1
 19c:	41 f0       	breq	.+16     	; 0x1ae <gpioPortWrite+0x14>
 19e:	28 f0       	brcs	.+10     	; 0x1aa <gpioPortWrite+0x10>
 1a0:	82 30       	cpi	r24, 0x02	; 2
 1a2:	39 f0       	breq	.+14     	; 0x1b2 <gpioPortWrite+0x18>
 1a4:	83 30       	cpi	r24, 0x03	; 3
 1a6:	41 f4       	brne	.+16     	; 0x1b8 <gpioPortWrite+0x1e>
 1a8:	06 c0       	rjmp	.+12     	; 0x1b6 <gpioPortWrite+0x1c>
	{
	case GPIOA:
		PORTA_DATA = u8_value;
 1aa:	6b bb       	out	0x1b, r22	; 27
		break;
 1ac:	08 95       	ret
	case GPIOB:
		PORTB_DATA = u8_value;
 1ae:	68 bb       	out	0x18, r22	; 24
		break;
 1b0:	08 95       	ret
	case GPIOC:
		PORTC_DATA = u8_value;
 1b2:	65 bb       	out	0x15, r22	; 21
		break;
 1b4:	08 95       	ret
	case GPIOD:
		PORTD_DATA = u8_value;
 1b6:	62 bb       	out	0x12, r22	; 18
 1b8:	08 95       	ret

000001ba <gpioPinDirection>:
	return Output;
}

void gpioPinDirection(uint8_t u8_port, uint8_t u8_pins, uint8_t u8_direction)
{
	switch (u8_direction)
 1ba:	44 23       	and	r20, r20
 1bc:	19 f0       	breq	.+6      	; 0x1c4 <gpioPinDirection+0xa>
 1be:	4f 3f       	cpi	r20, 0xFF	; 255
 1c0:	61 f5       	brne	.+88     	; 0x21a <gpioPinDirection+0x60>
 1c2:	14 c0       	rjmp	.+40     	; 0x1ec <gpioPinDirection+0x32>
	{
	case INPUT:
		switch (u8_port)
 1c4:	81 30       	cpi	r24, 0x01	; 1
 1c6:	49 f0       	breq	.+18     	; 0x1da <gpioPinDirection+0x20>
 1c8:	28 f0       	brcs	.+10     	; 0x1d4 <gpioPinDirection+0x1a>
 1ca:	82 30       	cpi	r24, 0x02	; 2
 1cc:	49 f0       	breq	.+18     	; 0x1e0 <gpioPinDirection+0x26>
 1ce:	83 30       	cpi	r24, 0x03	; 3
 1d0:	21 f5       	brne	.+72     	; 0x21a <gpioPinDirection+0x60>
 1d2:	09 c0       	rjmp	.+18     	; 0x1e6 <gpioPinDirection+0x2c>
		{
			case GPIOA:
			PORTA_DIR &= ~u8_direction;
 1d4:	8a b3       	in	r24, 0x1a	; 26
 1d6:	8a bb       	out	0x1a, r24	; 26
			break;
 1d8:	08 95       	ret
			case GPIOB:
			PORTB_DIR &= ~u8_direction;
 1da:	87 b3       	in	r24, 0x17	; 23
 1dc:	87 bb       	out	0x17, r24	; 23
			break;
 1de:	08 95       	ret
			case GPIOC:
			PORTC_DIR &= ~u8_direction;
 1e0:	84 b3       	in	r24, 0x14	; 20
 1e2:	84 bb       	out	0x14, r24	; 20
			break;
 1e4:	08 95       	ret
			case GPIOD:
			PORTD_DIR &= ~u8_direction;
 1e6:	81 b3       	in	r24, 0x11	; 17
 1e8:	81 bb       	out	0x11, r24	; 17
			break;
 1ea:	08 95       	ret
		}
		break;
	case OUTPUT:
		switch (u8_port)
 1ec:	81 30       	cpi	r24, 0x01	; 1
 1ee:	51 f0       	breq	.+20     	; 0x204 <gpioPinDirection+0x4a>
 1f0:	28 f0       	brcs	.+10     	; 0x1fc <gpioPinDirection+0x42>
 1f2:	82 30       	cpi	r24, 0x02	; 2
 1f4:	59 f0       	breq	.+22     	; 0x20c <gpioPinDirection+0x52>
 1f6:	83 30       	cpi	r24, 0x03	; 3
 1f8:	81 f4       	brne	.+32     	; 0x21a <gpioPinDirection+0x60>
 1fa:	0c c0       	rjmp	.+24     	; 0x214 <gpioPinDirection+0x5a>
		{
			case GPIOA:
				PORTA_DIR |= u8_direction;
 1fc:	8a b3       	in	r24, 0x1a	; 26
 1fe:	8f ef       	ldi	r24, 0xFF	; 255
 200:	8a bb       	out	0x1a, r24	; 26
				break;
 202:	08 95       	ret
			case GPIOB:
				PORTB_DIR |= u8_direction;
 204:	87 b3       	in	r24, 0x17	; 23
 206:	8f ef       	ldi	r24, 0xFF	; 255
 208:	87 bb       	out	0x17, r24	; 23
				break;
 20a:	08 95       	ret
			case GPIOC:
				PORTC_DIR |= u8_direction;
 20c:	84 b3       	in	r24, 0x14	; 20
 20e:	8f ef       	ldi	r24, 0xFF	; 255
 210:	84 bb       	out	0x14, r24	; 20
				break;
 212:	08 95       	ret
			case GPIOD:
				PORTD_DIR |= u8_direction;
 214:	81 b3       	in	r24, 0x11	; 17
 216:	8f ef       	ldi	r24, 0xFF	; 255
 218:	81 bb       	out	0x11, r24	; 17
 21a:	08 95       	ret

0000021c <gpioPinWrite>:
	}
}

void gpioPinWrite(uint8_t u8_port, uint8_t u8_pins, uint8_t u8_value)
{
	switch (u8_value)
 21c:	41 11       	cpse	r20, r1
 21e:	1d c0       	rjmp	.+58     	; 0x25a <gpioPinWrite+0x3e>
	{
		case LOW:
		switch (u8_port)
 220:	81 30       	cpi	r24, 0x01	; 1
 222:	61 f0       	breq	.+24     	; 0x23c <gpioPinWrite+0x20>
 224:	30 f0       	brcs	.+12     	; 0x232 <gpioPinWrite+0x16>
 226:	82 30       	cpi	r24, 0x02	; 2
 228:	71 f0       	breq	.+28     	; 0x246 <gpioPinWrite+0x2a>
 22a:	83 30       	cpi	r24, 0x03	; 3
 22c:	09 f0       	breq	.+2      	; 0x230 <gpioPinWrite+0x14>
 22e:	44 c0       	rjmp	.+136    	; 0x2b8 <gpioPinWrite+0x9c>
 230:	0f c0       	rjmp	.+30     	; 0x250 <gpioPinWrite+0x34>
		{
			case GPIOA:
				PORTA_DATA &= ~u8_pins;
 232:	8b b3       	in	r24, 0x1b	; 27
 234:	60 95       	com	r22
 236:	68 23       	and	r22, r24
 238:	6b bb       	out	0x1b, r22	; 27
				break;
 23a:	08 95       	ret
			case GPIOB:
				PORTB_DATA &= ~u8_pins;
 23c:	88 b3       	in	r24, 0x18	; 24
 23e:	60 95       	com	r22
 240:	68 23       	and	r22, r24
 242:	68 bb       	out	0x18, r22	; 24
				break;
 244:	08 95       	ret
			case GPIOC:
				PORTC_DATA &= ~u8_pins;
 246:	85 b3       	in	r24, 0x15	; 21
 248:	60 95       	com	r22
 24a:	68 23       	and	r22, r24
 24c:	65 bb       	out	0x15, r22	; 21
				break;
 24e:	08 95       	ret
			case GPIOD:
				PORTD_DATA &= ~u8_pins;
 250:	82 b3       	in	r24, 0x12	; 18
 252:	60 95       	com	r22
 254:	68 23       	and	r22, r24
 256:	62 bb       	out	0x12, r22	; 18
				break;
 258:	08 95       	ret
		}
		break;
		default:
		switch (u8_port)
 25a:	81 30       	cpi	r24, 0x01	; 1
 25c:	81 f0       	breq	.+32     	; 0x27e <gpioPinWrite+0x62>
 25e:	28 f0       	brcs	.+10     	; 0x26a <gpioPinWrite+0x4e>
 260:	82 30       	cpi	r24, 0x02	; 2
 262:	b9 f0       	breq	.+46     	; 0x292 <gpioPinWrite+0x76>
 264:	83 30       	cpi	r24, 0x03	; 3
 266:	41 f5       	brne	.+80     	; 0x2b8 <gpioPinWrite+0x9c>
 268:	1e c0       	rjmp	.+60     	; 0x2a6 <gpioPinWrite+0x8a>
		{
			case GPIOA:
			{
				PORTA_DATA &= ~u8_pins;
 26a:	8b b3       	in	r24, 0x1b	; 27
 26c:	96 2f       	mov	r25, r22
 26e:	90 95       	com	r25
 270:	89 23       	and	r24, r25
 272:	8b bb       	out	0x1b, r24	; 27
				u8_pins &= u8_value;
				PORTA_DATA |= u8_pins;
 274:	8b b3       	in	r24, 0x1b	; 27
		switch (u8_port)
		{
			case GPIOA:
			{
				PORTA_DATA &= ~u8_pins;
				u8_pins &= u8_value;
 276:	46 23       	and	r20, r22
				PORTA_DATA |= u8_pins;
 278:	48 2b       	or	r20, r24
 27a:	4b bb       	out	0x1b, r20	; 27
			}
				break;
 27c:	08 95       	ret
			case GPIOB:
			{
				PORTB_DATA &= ~u8_pins;
 27e:	88 b3       	in	r24, 0x18	; 24
 280:	96 2f       	mov	r25, r22
 282:	90 95       	com	r25
 284:	89 23       	and	r24, r25
 286:	88 bb       	out	0x18, r24	; 24
				u8_pins &= u8_value;
				PORTB_DATA |= u8_pins;
 288:	88 b3       	in	r24, 0x18	; 24
			}
				break;
			case GPIOB:
			{
				PORTB_DATA &= ~u8_pins;
				u8_pins &= u8_value;
 28a:	46 23       	and	r20, r22
				PORTB_DATA |= u8_pins;
 28c:	48 2b       	or	r20, r24
 28e:	48 bb       	out	0x18, r20	; 24
			}
				break;
 290:	08 95       	ret
			case GPIOC:
			{
				PORTC_DATA &= ~u8_pins;
 292:	85 b3       	in	r24, 0x15	; 21
 294:	96 2f       	mov	r25, r22
 296:	90 95       	com	r25
 298:	89 23       	and	r24, r25
 29a:	85 bb       	out	0x15, r24	; 21
				u8_pins &= u8_value;
				PORTC_DATA |= u8_pins;
 29c:	85 b3       	in	r24, 0x15	; 21
			}
				break;
			case GPIOC:
			{
				PORTC_DATA &= ~u8_pins;
				u8_pins &= u8_value;
 29e:	46 23       	and	r20, r22
				PORTC_DATA |= u8_pins;
 2a0:	48 2b       	or	r20, r24
 2a2:	45 bb       	out	0x15, r20	; 21
			}
				break;
 2a4:	08 95       	ret
			case GPIOD:
			{
				PORTD_DATA &= ~u8_pins;
 2a6:	82 b3       	in	r24, 0x12	; 18
 2a8:	96 2f       	mov	r25, r22
 2aa:	90 95       	com	r25
 2ac:	89 23       	and	r24, r25
 2ae:	82 bb       	out	0x12, r24	; 18
				u8_pins &= u8_value;
				PORTD_DATA |= u8_pins;
 2b0:	82 b3       	in	r24, 0x12	; 18
			}
				break;
			case GPIOD:
			{
				PORTD_DATA &= ~u8_pins;
				u8_pins &= u8_value;
 2b2:	46 23       	and	r20, r22
				PORTD_DATA |= u8_pins;
 2b4:	48 2b       	or	r20, r24
 2b6:	42 bb       	out	0x12, r20	; 18
 2b8:	08 95       	ret

000002ba <Led_Init>:
#include "ledConfig.h"
#include "led.h"

void Led_Init(En_LedNumber_t en_led_id)
{
	switch (en_led_id)
 2ba:	81 30       	cpi	r24, 0x01	; 1
 2bc:	61 f0       	breq	.+24     	; 0x2d6 <Led_Init+0x1c>
 2be:	28 f0       	brcs	.+10     	; 0x2ca <Led_Init+0x10>
 2c0:	82 30       	cpi	r24, 0x02	; 2
 2c2:	79 f0       	breq	.+30     	; 0x2e2 <Led_Init+0x28>
 2c4:	83 30       	cpi	r24, 0x03	; 3
 2c6:	c1 f4       	brne	.+48     	; 0x2f8 <Led_Init+0x3e>
 2c8:	12 c0       	rjmp	.+36     	; 0x2ee <Led_Init+0x34>
	{
	case LED_0:
		gpioPinDirection(LED_0_GPIO,LED_0_BIT,OUTPUT);
 2ca:	4f ef       	ldi	r20, 0xFF	; 255
 2cc:	60 e1       	ldi	r22, 0x10	; 16
 2ce:	81 e0       	ldi	r24, 0x01	; 1
 2d0:	0e 94 dd 00 	call	0x1ba	; 0x1ba <gpioPinDirection>
		break;
 2d4:	08 95       	ret
	case LED_1:
		gpioPinDirection(LED_1_GPIO,LED_1_BIT,OUTPUT);
 2d6:	4f ef       	ldi	r20, 0xFF	; 255
 2d8:	60 e2       	ldi	r22, 0x20	; 32
 2da:	81 e0       	ldi	r24, 0x01	; 1
 2dc:	0e 94 dd 00 	call	0x1ba	; 0x1ba <gpioPinDirection>
		break;
 2e0:	08 95       	ret
	case LED_2:
		gpioPinDirection(LED_2_GPIO,LED_2_BIT,OUTPUT);
 2e2:	4f ef       	ldi	r20, 0xFF	; 255
 2e4:	60 e4       	ldi	r22, 0x40	; 64
 2e6:	81 e0       	ldi	r24, 0x01	; 1
 2e8:	0e 94 dd 00 	call	0x1ba	; 0x1ba <gpioPinDirection>
		break;
 2ec:	08 95       	ret
	case LED_3:
		gpioPinDirection(LED_3_GPIO,LED_3_BIT,OUTPUT);
 2ee:	4f ef       	ldi	r20, 0xFF	; 255
 2f0:	60 e8       	ldi	r22, 0x80	; 128
 2f2:	81 e0       	ldi	r24, 0x01	; 1
 2f4:	0e 94 dd 00 	call	0x1ba	; 0x1ba <gpioPinDirection>
 2f8:	08 95       	ret

000002fa <Led_Off>:
	}
}

void Led_Off(En_LedNumber_t en_led_id)
{
	switch (en_led_id)
 2fa:	81 30       	cpi	r24, 0x01	; 1
 2fc:	61 f0       	breq	.+24     	; 0x316 <Led_Off+0x1c>
 2fe:	28 f0       	brcs	.+10     	; 0x30a <Led_Off+0x10>
 300:	82 30       	cpi	r24, 0x02	; 2
 302:	79 f0       	breq	.+30     	; 0x322 <Led_Off+0x28>
 304:	83 30       	cpi	r24, 0x03	; 3
 306:	c1 f4       	brne	.+48     	; 0x338 <Led_Off+0x3e>
 308:	12 c0       	rjmp	.+36     	; 0x32e <Led_Off+0x34>
	{
	case LED_0:
		gpioPinWrite(LED_0_GPIO,LED_0_BIT,LOW);
 30a:	40 e0       	ldi	r20, 0x00	; 0
 30c:	60 e1       	ldi	r22, 0x10	; 16
 30e:	81 e0       	ldi	r24, 0x01	; 1
 310:	0e 94 0e 01 	call	0x21c	; 0x21c <gpioPinWrite>
		break;
 314:	08 95       	ret
	case LED_1:
		gpioPinWrite(LED_1_GPIO,LED_1_BIT,LOW);
 316:	40 e0       	ldi	r20, 0x00	; 0
 318:	60 e2       	ldi	r22, 0x20	; 32
 31a:	81 e0       	ldi	r24, 0x01	; 1
 31c:	0e 94 0e 01 	call	0x21c	; 0x21c <gpioPinWrite>
		break;
 320:	08 95       	ret
	case LED_2:
		gpioPinWrite(LED_2_GPIO,LED_2_BIT,LOW);
 322:	40 e0       	ldi	r20, 0x00	; 0
 324:	60 e4       	ldi	r22, 0x40	; 64
 326:	81 e0       	ldi	r24, 0x01	; 1
 328:	0e 94 0e 01 	call	0x21c	; 0x21c <gpioPinWrite>
		break;
 32c:	08 95       	ret
	case LED_3:
		gpioPinWrite(LED_3_GPIO,LED_3_BIT,LOW);
 32e:	40 e0       	ldi	r20, 0x00	; 0
 330:	60 e8       	ldi	r22, 0x80	; 128
 332:	81 e0       	ldi	r24, 0x01	; 1
 334:	0e 94 0e 01 	call	0x21c	; 0x21c <gpioPinWrite>
 338:	08 95       	ret

0000033a <SwICU_Init>:
#include "SwICU.h"

void SwICU_Init(EN_SwICU_Edge_t a_en_inputCaptureEdge)
{
 33a:	ef 92       	push	r14
 33c:	0f 93       	push	r16
 33e:	cf 93       	push	r28
 340:	c8 2f       	mov	r28, r24
    timer0Init(T0_NORMAL_MODE,T0_OC0_DIS,T0_PRESCALER_256,0x00,0x00,T0_POLLING);
 342:	e1 2c       	mov	r14, r1
 344:	00 e0       	ldi	r16, 0x00	; 0
 346:	20 e0       	ldi	r18, 0x00	; 0
 348:	44 e0       	ldi	r20, 0x04	; 4
 34a:	60 e0       	ldi	r22, 0x00	; 0
 34c:	80 e0       	ldi	r24, 0x00	; 0
 34e:	0e 94 ea 01 	call	0x3d4	; 0x3d4 <timer0Init>
	Current_Edge = SwICU_EdgeRisiging;
 352:	83 e0       	ldi	r24, 0x03	; 3
 354:	80 93 68 00 	sts	0x0068, r24

    switch(a_en_inputCaptureEdge)
 358:	c2 30       	cpi	r28, 0x02	; 2
 35a:	89 f0       	breq	.+34     	; 0x37e <SwICU_Init+0x44>
 35c:	c3 30       	cpi	r28, 0x03	; 3
 35e:	e9 f4       	brne	.+58     	; 0x39a <SwICU_Init+0x60>
    {
        case SwICU_EdgeRisiging:
            CLEARBITS(SREG,0x80);                              // Disable interrupts by clearing I-bit
 360:	8f b7       	in	r24, 0x3f	; 63
 362:	8f 77       	andi	r24, 0x7F	; 127
 364:	8f bf       	out	0x3f, r24	; 63
            gpioPinDirection(GPIOD,BIT2,INPUT); // Configure INT0/PD2 as input pin
 366:	40 e0       	ldi	r20, 0x00	; 0
 368:	64 e0       	ldi	r22, 0x04	; 4
 36a:	83 e0       	ldi	r24, 0x03	; 3
 36c:	0e 94 dd 00 	call	0x1ba	; 0x1ba <gpioPinDirection>
            SETBITS(MCUCR,0x03);                // Trigger INT0 with the raising edge
 370:	85 b7       	in	r24, 0x35	; 53
 372:	83 60       	ori	r24, 0x03	; 3
 374:	85 bf       	out	0x35, r24	; 53
            SETBITS(SREG,0x80);                              // Enable interrupts by setting I-bit
 376:	8f b7       	in	r24, 0x3f	; 63
 378:	80 68       	ori	r24, 0x80	; 128
 37a:	8f bf       	out	0x3f, r24	; 63
            break;
 37c:	0e c0       	rjmp	.+28     	; 0x39a <SwICU_Init+0x60>

        case SwICU_EdgeFalling:
            CLEARBITS(SREG,0x80);                              // Disable interrupts by clearing I-bit
 37e:	8f b7       	in	r24, 0x3f	; 63
 380:	8f 77       	andi	r24, 0x7F	; 127
 382:	8f bf       	out	0x3f, r24	; 63
            gpioPinDirection(GPIOD,BIT2,INPUT); // Configure INT0/PD2 as input pin
 384:	40 e0       	ldi	r20, 0x00	; 0
 386:	64 e0       	ldi	r22, 0x04	; 4
 388:	83 e0       	ldi	r24, 0x03	; 3
 38a:	0e 94 dd 00 	call	0x1ba	; 0x1ba <gpioPinDirection>
            SETBITS(MCUCR,0x02);                // Trigger INT0 with the falling edge
 38e:	85 b7       	in	r24, 0x35	; 53
 390:	82 60       	ori	r24, 0x02	; 2
 392:	85 bf       	out	0x35, r24	; 53
            SETBITS(SREG,0x80);                              // Enable interrupts by setting I-bit
 394:	8f b7       	in	r24, 0x3f	; 63
 396:	80 68       	ori	r24, 0x80	; 128
 398:	8f bf       	out	0x3f, r24	; 63
            break;
    }
}
 39a:	cf 91       	pop	r28
 39c:	0f 91       	pop	r16
 39e:	ef 90       	pop	r14
 3a0:	08 95       	ret

000003a2 <SwICU_SetCfgEdge>:

void SwICU_SetCfgEdge(EN_SwICU_Edge_t a_en_inputCaptureEdgeedge)
{
    switch(a_en_inputCaptureEdgeedge)
 3a2:	82 30       	cpi	r24, 0x02	; 2
 3a4:	31 f0       	breq	.+12     	; 0x3b2 <SwICU_SetCfgEdge+0x10>
 3a6:	83 30       	cpi	r24, 0x03	; 3
 3a8:	39 f4       	brne	.+14     	; 0x3b8 <SwICU_SetCfgEdge+0x16>
    {
        case SwICU_EdgeRisiging:
            SETBITS(MCUCR,0x03);                // Trigger INT0 with the raising edge
 3aa:	85 b7       	in	r24, 0x35	; 53
 3ac:	83 60       	ori	r24, 0x03	; 3
 3ae:	85 bf       	out	0x35, r24	; 53
            break;
 3b0:	08 95       	ret

    case SwICU_EdgeFalling:
            SETBITS(MCUCR,0x02);                // Trigger INT0 with the falling edge
 3b2:	85 b7       	in	r24, 0x35	; 53
 3b4:	82 60       	ori	r24, 0x02	; 2
 3b6:	85 bf       	out	0x35, r24	; 53
 3b8:	08 95       	ret

000003ba <SwICU_Read>:
            break;
    }
}
void SwICU_Read(volatile uint8_t * a_pu8_capt)
{
 3ba:	cf 93       	push	r28
 3bc:	df 93       	push	r29
 3be:	ec 01       	movw	r28, r24
    *a_pu8_capt = timer0Read();
 3c0:	0e 94 0c 02 	call	0x418	; 0x418 <timer0Read>
 3c4:	88 83       	st	Y, r24
}
 3c6:	df 91       	pop	r29
 3c8:	cf 91       	pop	r28
 3ca:	08 95       	ret

000003cc <SwICU_Start>:
{
    CLEARBITS(GICR,0x40);                // Enable external interrupt pin INT0
}
void SwICU_Start(void)
{
    SETBITS(GICR,0x40);                 // Enable external interrupt pin INT0
 3cc:	8b b7       	in	r24, 0x3b	; 59
 3ce:	80 64       	ori	r24, 0x40	; 64
 3d0:	8b bf       	out	0x3b, r24	; 59
 3d2:	08 95       	ret

000003d4 <timer0Init>:
 * @param initialValue
 * @param outputCompare
 * @param interruptMask
 */
void timer0Init(En_timer0Mode_t en_mode,En_timer0OC_t en_OC0,En_timer0perscaler_t en_prescal, uint8_t u8_initialValue, uint8_t u8_outputCompare, En_timer0Interrupt_t en_interruptMask)
{
 3d4:	ef 92       	push	r14
 3d6:	0f 93       	push	r16
    Timer_Config.Timer_Mode = en_mode;
 3d8:	80 93 60 00 	sts	0x0060, r24
    Timer_Config.Timer_OC = en_OC0;
 3dc:	60 93 61 00 	sts	0x0061, r22
    Timer_Config.Timer_Pre = en_prescal;
 3e0:	40 93 62 00 	sts	0x0062, r20
    Timer_Config.Timer_Init_Value = u8_initialValue;
 3e4:	20 93 63 00 	sts	0x0063, r18
    Timer_Config.Timer_Comp_Value = u8_outputCompare;
 3e8:	00 93 64 00 	sts	0x0064, r16
    Timer_Config.Timer_Interrupt = en_interruptMask;
 3ec:	e0 92 65 00 	sts	0x0065, r14

    CLEARBITS(TCNT0,0xFF);
 3f0:	92 b7       	in	r25, 0x32	; 50
 3f2:	12 be       	out	0x32, r1	; 50
    CLEARBITS(OCR0,0xFF);
 3f4:	9c b7       	in	r25, 0x3c	; 60
 3f6:	1c be       	out	0x3c, r1	; 60
    SETBITS(TCNT0,u8_initialValue);
 3f8:	92 b7       	in	r25, 0x32	; 50
 3fa:	29 2b       	or	r18, r25
 3fc:	22 bf       	out	0x32, r18	; 50
    SETBITS(TCCR0,(en_mode|en_OC0));
 3fe:	93 b7       	in	r25, 0x33	; 51
 400:	89 2b       	or	r24, r25
 402:	68 2b       	or	r22, r24
 404:	63 bf       	out	0x33, r22	; 51
    SETBITS(OCR0,u8_outputCompare);
 406:	8c b7       	in	r24, 0x3c	; 60
 408:	08 2b       	or	r16, r24
 40a:	0c bf       	out	0x3c, r16	; 60
    SETBITS(TIMSK,en_interruptMask);
 40c:	89 b7       	in	r24, 0x39	; 57
 40e:	e8 2a       	or	r14, r24
 410:	e9 be       	out	0x39, r14	; 57

}
 412:	0f 91       	pop	r16
 414:	ef 90       	pop	r14
 416:	08 95       	ret

00000418 <timer0Read>:
    SETBITS(TCNT0,u8_value);
}

uint8_t timer0Read(void)
{
    return TCNT0;
 418:	82 b7       	in	r24, 0x32	; 50
}
 41a:	08 95       	ret

0000041c <timer0Start>:

void timer0Start(void)
{
    SETBITS(TCCR0,Timer_Config.Timer_Pre);
 41c:	93 b7       	in	r25, 0x33	; 51
 41e:	80 91 62 00 	lds	r24, 0x0062
 422:	89 2b       	or	r24, r25
 424:	83 bf       	out	0x33, r24	; 51
 426:	08 95       	ret

00000428 <timer0Stop>:
}

void timer0Stop(void)
{
    CLEARBITS(TCCR0,0x07);
 428:	83 b7       	in	r24, 0x33	; 51
 42a:	88 7f       	andi	r24, 0xF8	; 248
 42c:	83 bf       	out	0x33, r24	; 51
 42e:	08 95       	ret

00000430 <timer0DelayMs>:
}

void timer0DelayMs(uint16_t u16_delay_in_ms)
{
 430:	ef 92       	push	r14
 432:	0f 93       	push	r16
 434:	cf 93       	push	r28
 436:	df 93       	push	r29
 438:	ec 01       	movw	r28, r24
    uint16_t counter=0;

    timer0Init(T0_COMP_MODE,T0_OC0_CLEAR,T0_PRESCALER_64,0x00,0xFA,T0_POLLING);
 43a:	e1 2c       	mov	r14, r1
 43c:	0a ef       	ldi	r16, 0xFA	; 250
 43e:	20 e0       	ldi	r18, 0x00	; 0
 440:	43 e0       	ldi	r20, 0x03	; 3
 442:	60 e2       	ldi	r22, 0x20	; 32
 444:	88 e0       	ldi	r24, 0x08	; 8
 446:	0e 94 ea 01 	call	0x3d4	; 0x3d4 <timer0Init>
    timer0Start();
 44a:	0e 94 0e 02 	call	0x41c	; 0x41c <timer0Start>

    SETBITS(TIFR,0x02);
 44e:	88 b7       	in	r24, 0x38	; 56
 450:	82 60       	ori	r24, 0x02	; 2
 452:	88 bf       	out	0x38, r24	; 56

    while(counter!=u16_delay_in_ms)
 454:	20 97       	sbiw	r28, 0x00	; 0
 456:	69 f0       	breq	.+26     	; 0x472 <timer0DelayMs+0x42>
    CLEARBITS(TCCR0,0x07);
}

void timer0DelayMs(uint16_t u16_delay_in_ms)
{
    uint16_t counter=0;
 458:	20 e0       	ldi	r18, 0x00	; 0
 45a:	30 e0       	ldi	r19, 0x00	; 0
    SETBITS(TIFR,0x02);

    while(counter!=u16_delay_in_ms)
    {

       while(ISCLEAR(TIFR,0x02))
 45c:	08 b6       	in	r0, 0x38	; 56
 45e:	01 fe       	sbrs	r0, 1
 460:	fd cf       	rjmp	.-6      	; 0x45c <timer0DelayMs+0x2c>
        {}
		SETBITS(TIFR,0x02);
 462:	88 b7       	in	r24, 0x38	; 56
 464:	82 60       	ori	r24, 0x02	; 2
 466:	88 bf       	out	0x38, r24	; 56
        counter++;
 468:	2f 5f       	subi	r18, 0xFF	; 255
 46a:	3f 4f       	sbci	r19, 0xFF	; 255
    timer0Init(T0_COMP_MODE,T0_OC0_CLEAR,T0_PRESCALER_64,0x00,0xFA,T0_POLLING);
    timer0Start();

    SETBITS(TIFR,0x02);

    while(counter!=u16_delay_in_ms)
 46c:	2c 17       	cp	r18, r28
 46e:	3d 07       	cpc	r19, r29
 470:	a9 f7       	brne	.-22     	; 0x45c <timer0DelayMs+0x2c>
        {}
		SETBITS(TIFR,0x02);
        counter++;
    }

}
 472:	df 91       	pop	r29
 474:	cf 91       	pop	r28
 476:	0f 91       	pop	r16
 478:	ef 90       	pop	r14
 47a:	08 95       	ret

0000047c <__divmodhi4>:
 47c:	97 fb       	bst	r25, 7
 47e:	07 2e       	mov	r0, r23
 480:	16 f4       	brtc	.+4      	; 0x486 <__divmodhi4+0xa>
 482:	00 94       	com	r0
 484:	07 d0       	rcall	.+14     	; 0x494 <__divmodhi4_neg1>
 486:	77 fd       	sbrc	r23, 7
 488:	09 d0       	rcall	.+18     	; 0x49c <__divmodhi4_neg2>
 48a:	0e 94 52 02 	call	0x4a4	; 0x4a4 <__udivmodhi4>
 48e:	07 fc       	sbrc	r0, 7
 490:	05 d0       	rcall	.+10     	; 0x49c <__divmodhi4_neg2>
 492:	3e f4       	brtc	.+14     	; 0x4a2 <__divmodhi4_exit>

00000494 <__divmodhi4_neg1>:
 494:	90 95       	com	r25
 496:	81 95       	neg	r24
 498:	9f 4f       	sbci	r25, 0xFF	; 255
 49a:	08 95       	ret

0000049c <__divmodhi4_neg2>:
 49c:	70 95       	com	r23
 49e:	61 95       	neg	r22
 4a0:	7f 4f       	sbci	r23, 0xFF	; 255

000004a2 <__divmodhi4_exit>:
 4a2:	08 95       	ret

000004a4 <__udivmodhi4>:
 4a4:	aa 1b       	sub	r26, r26
 4a6:	bb 1b       	sub	r27, r27
 4a8:	51 e1       	ldi	r21, 0x11	; 17
 4aa:	07 c0       	rjmp	.+14     	; 0x4ba <__udivmodhi4_ep>

000004ac <__udivmodhi4_loop>:
 4ac:	aa 1f       	adc	r26, r26
 4ae:	bb 1f       	adc	r27, r27
 4b0:	a6 17       	cp	r26, r22
 4b2:	b7 07       	cpc	r27, r23
 4b4:	10 f0       	brcs	.+4      	; 0x4ba <__udivmodhi4_ep>
 4b6:	a6 1b       	sub	r26, r22
 4b8:	b7 0b       	sbc	r27, r23

000004ba <__udivmodhi4_ep>:
 4ba:	88 1f       	adc	r24, r24
 4bc:	99 1f       	adc	r25, r25
 4be:	5a 95       	dec	r21
 4c0:	a9 f7       	brne	.-22     	; 0x4ac <__udivmodhi4_loop>
 4c2:	80 95       	com	r24
 4c4:	90 95       	com	r25
 4c6:	bc 01       	movw	r22, r24
 4c8:	cd 01       	movw	r24, r26
 4ca:	08 95       	ret

000004cc <_exit>:
 4cc:	f8 94       	cli

000004ce <__stop_program>:
 4ce:	ff cf       	rjmp	.-2      	; 0x4ce <__stop_program>
